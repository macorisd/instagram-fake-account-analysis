{"title":"Formal Concept Analysis","markdown":{"yaml":{"title":"Formal Concept Analysis"},"headingText":"Librerías, datasets y procesamiento previo","containsRefs":false,"markdown":"\n\n```{r warning=FALSE, message=FALSE}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(fcaR)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(psych)\nlibrary(arules)\n\ndatos <- read_csv(\"train.csv\")\nView(datos)\ndatos_test <- read_csv(\"test.csv\")\nView(datos_test)\n\ndatos <- rename(datos, profile_pic=`profile pic`, `nums/length_username` = `nums/length username`, fullname_words=`fullname words`, `nums/length_fullname` = `nums/length fullname`, description_length=`description length`, external_URL=`external URL`, posts=`#posts`, followers=`#followers`, follows=`#follows`)\n\ndatos_test <- rename(datos_test, profile_pic=`profile pic`, `nums/length_username` = `nums/length username`, fullname_words=`fullname words`, `nums/length_fullname` = `nums/length fullname`, description_length=`description length`, external_URL=`external URL`, posts=`#posts`, followers=`#followers`, follows=`#follows`)\n```\n\n## Formal Concept Analysis\n\nYa hemos extraído información importante sobre patrones encontrados en los datos, concretamente sobre qué atributos o combinaciones de ellos determinan, con mayor o menor influencia, si una cuenta es legítima o falsa. Sin embargo, el estudio de reglas de asociación no es la única forma de extraer información en cuanto a las relaciones entre variables y el descubrimiento de patrones: es momento de estudiar lo que se conoce como \"Formal Concept Analysis\".\n\n### Obtención de las reglas de FCA\n\nMi primer paso para trabajar con FCA va a consistir en construir una matriz, cuyas filas serán las cuentas del dataset, cuyas columnas serán los valores discretizados de las variables (2 columnas por cada variable binaria y 3 por cada variable numérica) y cuyas celdas serán valores 0/1, en función del valor discretizado que cumpla esa cuenta para cada variable. Es decir, trabajaremos con un formal context binario.\n\nPara comenzar con esta aproximación, antes es necesario ajustar un poco los intervalos de las variables numéricas que hemos visto en reglas de asociación, para que haya 3 categorías (serán high, med y low). En las variables binarias seguimos el mismo procedimiento que en reglas de asociación.\n\n```{r}\ndatosDF_FCA_intervalos <- data.frame(datos)\nView(datosDF_FCA_intervalos)\n\n# Discretizar columnas numéricas\ndatosDF_FCA_intervalos$nums.length_username <- discretize(datosDF_FCA_intervalos$nums.length_username, method=\"interval\", breaks = 3)\ndatosDF_FCA_intervalos$fullname_words <- discretize(datosDF_FCA_intervalos$fullname_words, method=\"frequency\", breaks = 3)\ndatosDF_FCA_intervalos$nums.length_fullname <- discretize(datosDF_FCA_intervalos$nums.length_fullname, method=\"interval\", breaks = 3)\ndatosDF_FCA_intervalos$description_length <- discretize(datosDF_FCA_intervalos$description_length, method=\"interval\", breaks = 3)\ndatosDF_FCA_intervalos$posts <- discretize(datosDF_FCA_intervalos$posts, method=\"frequency\", breaks = 3)\ndatosDF_FCA_intervalos$followers <- discretize(datosDF_FCA_intervalos$followers, method=\"frequency\", breaks = 3)\ndatosDF_FCA_intervalos$follows <- discretize(datosDF_FCA_intervalos$follows, method=\"frequency\", breaks = 3)\n\n# Identificar las columnas binarias y numéricas\ncolumnas_binarias <- c(1, 5, 7, 8, 12) # Índices de las columnas binarias\n\n# Convertir columnas binarias a factores\ndatosDF_FCA_intervalos[, columnas_binarias] <- lapply(datosDF_FCA_intervalos[, columnas_binarias], factor)\nView(datosDF_FCA_intervalos)\n\n\n```\n\nYa tenemos los nuevos intervalos ajustados. Ahora toca imprimir los valores de esos intervalos, que usaremos posteriormente para definir los valores de cada cuenta en la matriz:\n\n```{r}\n# Obtener los niveles de cada variable recorriendo las columnas\nfor (col_name in names(datosDF_FCA_intervalos)) {\n  col <- datosDF_FCA_intervalos[[col_name]]\n  if (is.factor(col)) {\n    cat(length(levels(col)), \" niveles en\", col_name, \":\", levels(col), \"\\n\")\n  }\n}\n```\n\nAhora ya tenemos los valores posibles que puede tomar cada variable. En las variables binarias, naturalmente los valores posibles son 0 y 1; en las numéricas hay 3 intervalos por variable.\n\nLo siguiente sería definir los atributos (categorías de las variables):\n\n```{r}\ndatosDF_FCA <- data.frame(datos)\nView(datosDF_FCA)\n\n# Crear un vector con los nombres de los atributos (categorías)\nattributes <- c(\"profile_pic\", \"no_profile_pic\",\n                \"nums_lun_high\", \"nums_lun_med\", \"nums_lun_low\",\n                \"fn_words_high\", \"fn_words_med\", \"fn_words_low\",\n                \"nums_lfn_high\", \"nums_lfn_med\", \"nums_lfn_low\",\n                \"fn_equals_un\", \"fn_notequals_un\",\n                \"desc_length_high\", \"desc_length_med\", \"desc_length_low\",\n                \"url\", \"no_url\",\n                \"private\", \"public\",\n                \"posts_high\", \"posts_med\", \"posts_low\",\n                \"followers_high\", \"followers_med\", \"followers_low\",\n                \"follows_high\", \"follows_med\", \"follows_low\",\n                \"fake\", \"real\")\n```\n\nUna vez tenemos definidos los atributos, es hora de crear el esqueleto de la matriz sobre la que aplicaremos FCA:\n\n```{r}\n# Crear un vector con los nombres de las cuentas\naccounts <- rownames(datosDF_FCA)\n\n# Crear una matriz de ceros con el mismo número de filas que cuentas y el mismo número de columnas que atributos\ndatosFCA <- matrix(0, nrow = nrow(datosDF_FCA), ncol = length(attributes))\n\n# Nombrar las filas y columnas\nrownames(datosFCA) <- accounts\ncolnames(datosFCA) <- attributes\n\n# Visualizar la matriz vacía\n#datosFCA\n```\n\nNuestra matriz vacía está lista. Ahora debemos llenarla, y para ello recorreremos cada fila del data frame, y examinaremos los valores de las columnas de esa fila. En función del valor que tome (comparado con los intervalos ajustados de antes), asignaremos un 1 o un 0 en la columna (categoría) correspondiente de la matriz para esa fila:\n\n```{r}\n# Iterar sobre cada fila del dataset y actualizar los valores en la matriz de acuerdo a los intervalos de las variables\nfor (i in 1:nrow(datosDF_FCA)) {\n  # profile_pic\n  if (datosDF_FCA[i, \"profile_pic\"] == 1) {\n    datosFCA[i, \"profile_pic\"] <- 1\n  } else {\n    datosFCA[i, \"no_profile_pic\"] <- 1\n  }\n  \n  # nums.length_username\n  if (datosDF_FCA[i, \"nums.length_username\"] < 0.307) {\n    datosFCA[i, \"nums_lun_low\"] <- 1\n  } else if (datosDF_FCA[i, \"nums.length_username\"] < 0.613) {\n    datosFCA[i, \"nums_lun_med\"] <- 1\n  } else {\n    datosFCA[i, \"nums_lun_high\"] <- 1\n  }\n  \n  # fullname_words\n  if (datosDF_FCA[i, \"fullname_words\"] < 1) {\n    datosFCA[i, \"fn_words_low\"] <- 1\n  } else if (datosDF_FCA[i, \"fullname_words\"] < 2) {\n    datosFCA[i, \"fn_words_med\"] <- 1\n  } else {\n    datosFCA[i, \"fn_words_high\"] <- 1\n  }\n  \n  # nums.length_fullname\n  if (datosDF_FCA[i, \"nums.length_fullname\"] < 0.333) {\n    datosFCA[i, \"nums_lfn_low\"] <- 1\n  } else if (datosDF_FCA[i, \"nums.length_fullname\"] < 0.667) {\n    datosFCA[i, \"nums_lfn_med\"] <- 1\n  } else {\n    datosFCA[i, \"nums_lfn_high\"] <- 1\n  }\n  \n  # Name.equals.username\n  if (datosDF_FCA[i, \"name..username\"] == 1) {\n    datosFCA[i, \"fn_equals_un\"] <- 1\n  } else {\n    datosFCA[i, \"fn_notequals_un\"] <- 1\n  }\n  \n  # description_length\n  if (datosDF_FCA[i, \"description_length\"] < 50) {\n    datosFCA[i, \"desc_length_low\"] <- 1\n  } else if (datosDF_FCA[i, \"description_length\"] < 100) {\n    datosFCA[i, \"desc_length_med\"] <- 1\n  } else {\n    datosFCA[i, \"desc_length_high\"] <- 1\n  }\n  \n  # external_URL\n  if (datosDF_FCA[i, \"external_URL\"] == 1) {\n    datosFCA[i, \"url\"] <- 1\n  } else {\n    datosFCA[i, \"no_url\"] <- 1\n  }\n  \n  # private\n  if (datosDF_FCA[i, \"private\"] == 1) {\n    datosFCA[i, \"private\"] <- 1\n  } else {\n    datosFCA[i, \"public\"] <- 1\n  }\n  \n  # posts\n  if (datosDF_FCA[i, \"posts\"] < 2) {\n    datosFCA[i, \"posts_low\"] <- 1\n  } else if (datosDF_FCA[i, \"posts\"] < 43.3) {\n    datosFCA[i, \"posts_med\"] <- 1\n  } else {\n    datosFCA[i, \"posts_high\"] <- 1\n  }\n  \n  # followers\n  if (datosDF_FCA[i, \"followers\"] < 54.3) {\n    datosFCA[i, \"followers_low\"] <- 1\n  } else if (datosDF_FCA[i, \"followers\"] < 415) {\n    datosFCA[i, \"followers_med\"] <- 1\n  } else {\n    datosFCA[i, \"followers_high\"] <- 1\n  }\n  \n  # follows\n  if (datosDF_FCA[i, \"follows\"] < 89.3) {\n    datosFCA[i, \"follows_low\"] <- 1\n  } else if (datosDF_FCA[i, \"follows\"] < 432) {\n    datosFCA[i, \"follows_med\"] <- 1\n  } else {\n    datosFCA[i, \"follows_high\"] <- 1\n  }\n  \n  # fake\n  if (datosDF_FCA[i, \"fake\"] == 1) {\n    datosFCA[i, \"fake\"] <- 1\n  } else {\n    datosFCA[i, \"real\"] <- 1\n  }\n}\n\n# Visualizar la matriz llena\n#datosFCA\n```\n\nAhora viene lo interesante: convertir la matriz a un objeto formalcontext y trabajar con FCA.\n\n```{r}\n# Convertir la matriz a un objeto FormalContext\nfc_datos <- FormalContext$new(datosFCA)\nfc_datos\n```\n\nVemos que la conversión ha sido exitosa. Además de ver la tabla, podemos hacer un plot para visualizar el resultado:\n\n```{r}\n# Visualizar el formal context\nfc_datos$plot()\n```\n\nNaturalmente, al ser tantos datos, no podemos ver bien cada fila. Sin embargo, podemos ver patrones que concuerdan con nuestro dataset: la última columna es 'fake', y sabemos que la primera mitad de filas son cuentas reales, y la segunda mitad, cuentas falsas, tal y como indican las barras negras del final del plot.\n\nObservemos más de cerca el plot (5 primeras filas):\n\n```{r}\nfc_datos[1:5]$plot()\n```\n\nComo vemos, las barras negras concuerdan perfectamente con nuestro dataset. Parece que hemos tenido éxito. También podemos comprobar este éxito usando el extent y el intent:\n\n```{r}\nS1 <- Set$new(fc_datos$attributes)\nS1$assign(fake=1)\n\n# Extent (filas) de las cuentas fake\nS2 <- fc_datos$extent(S1)\nS2\n```\n\nEl extent lista los nombres de las filas con cuentas que cumplen las condiciones establecidas en S1 (las cuentas son fake). Echando un vistazo al dataset, comprobamos que las filas de la salida (289-576) son las cuentas fake. También existe el concepto de intent, el cual devuelve el conjunto de características que comparte un conjunto de filas. Por esa lógica, si hiciéramos el intent de S2 (cuentas fake), debería devolvernos fake y no_url, dado que ninguna cuenta fake tiene URL externa:\n\n```{r}\n# Intent (características) de las cuentas fake\nfc_datos$intent(S2)\n```\n\nUna vez más, parece que ha habido éxito.\n\nAhora es momento de encontrar las implicaciones:\n\n```{r}\n# Encontrar implicaciones\nfc_datos$find_implications()\n\n# Número de implicaciones encontradas\nfc_datos$implications$cardinality()\n```\n\nAhora que sabemos que hay un número considerable de implicaciones, intentemos reducir la cantidad eliminando redundancias:\n\n```{r}\nfc_datos$implications$apply_rules(rules = c(\"composition\",\n                                      \"generalization\",\n                                      \"simplification\"),\n                            parallelize = FALSE)\n```\n\nParece que ninguna de las implicaciones originales era redundante. Echemos un vistazo a las primeras 20 implicaciones:\n\n```{r}\nfc_datos$implications[1:20]\n```\n\nAhora es el momento de extraer conocimiento con las implicaciones que nos interesan (variable fake en el consecuente de la regla).\n\nComencemos con las reglas cuyo consecuente es únicamente 'fake' (si además de fake se dejan otras variables, el resultado tiene mucho ruido y reglas extrañas):\n\n```{r}\n# Implicaciones con 'fake' en el consecuente\nfc_datos$implications$filter(rhs = \"fake\", not_rhs = attributes[-which(attributes == \"fake\")])\n```\n\nBasándonos en estas reglas, podemos considerar que una cuenta es falsa cuando identificamos ciertas combinaciones de estas características:\n\n-   Pocas o nulas publicaciones (igual que en reglas de asociación)\n-   Descripción vacía o muy breve (igual que en reglas de asociación)\n-   Ausencia de foto de perfil (igual que en reglas de asociación)\n-   Pocos o nulos seguidos (igual que en reglas de asociación)\n-   Ausencia de URL externa (igual que en reglas de asociación)\n-   Bajo número de seguidores\n\nComo vemos, las conclusiones generales son muy similares a las obtenidas con arules.\n\nAhora veamos los antecedentes para cuentas verdaderas:\n\n```{r}\n# Implicaciones con 'real' en el consecuente\nfc_datos$implications$filter(rhs = \"real\", not_rhs = attributes[-which(attributes == \"real\")])\n```\n\nBasándonos en estas reglas, podemos considerar que una cuenta es verdadera cuando identificamos ciertas combinaciones de estas características:\n\n-   Ratio de números en la longitud del username bajo (igual que en reglas de asociación)\n-   Cantidad considerable de palabras en el nombre completo (igual que en reglas de asociación)\n-   Presencia de foto de perfil (igual que en reglas de asociación)\n-   Descripción detallada (igual que en reglas de asociación)\n-   Número alto de publicaciones (igual que en reglas de asociación)\n-   Número considerable de seguidores (ya comentamos que este parámetro faltó en reglas de asociación, pero aquí sí aparece)\n\nLas conclusiones generales para cuentas verdaderas también son muy similares a las obtenidas con arules.\n\n### Predicción\n\nAhora es el momento de usar las reglas obtenidas para predecir la veracidad de las cuentas en el dataset de test. Para ello, debemos organizar los datos de test de la misma forma que los de entrenamiento. Como me ha gustado el modo de trabajar con el formato de reglas de arules, primero convertiré las reglas obtenidas a arules para poder aplicarlas a los datos de test.\n\n```{r}\n# Convertir las implicaciones a reglas de asociación\nreglas_FCA <- fc_datos$implications$to_arules()\n\n# Mostrar la primera regla obtenida\ninspect(reglas_FCA[1])\n```\n\nMostremos el número de reglas obtenidas, que debería ser 1292:\n\n```{r}\n# Número de reglas obtenidas\nlength(reglas_FCA)\n```\n\nParece que las reglas se han convertido con éxito a formato arules.\n\nAhora, debemos crear una matriz de datos de test con las mismas características que la matriz de datos de entrenamiento:\n\n```{r}\n# Crear un vector con los nombres de las cuentas\naccounts <- rownames(datos_test)\n\n# Crear lista con atributos para las filas de test (sin real ni fake)\nattributes_test <- attributes[-which(attributes %in% c(\"fake\", \"real\"))]\n\n# Crear una matriz de ceros con el mismo número de filas que cuentas y el mismo número de columnas que atributos\ndatosFCA_test <- matrix(0, nrow = nrow(datos_test), ncol = length(attributes_test))\n\n# Nombrar las filas y columnas\nrownames(datosFCA_test) <- accounts\ncolnames(datosFCA_test) <- attributes_test\n\n# Visualizar la matriz vacía\n#datosFCA_test\n```\n\nAhora, debemos llenar la matriz de datos de test con los valores correspondientes a cada cuenta, fijándonos en los intervalos generados para las cuentas de entrenamiento:\n\n```{r}\ndatosDF_FCA_test <- data.frame(datos_test)\n\n# Iterar sobre cada fila del dataset y actualizar los valores en la matriz de acuerdo a los intervalos de las variables\nfor (i in 1:nrow(datosDF_FCA_test)) {\n  # profile_pic\n  if (datosDF_FCA_test[i, \"profile_pic\"] == 1) {\n    datosFCA_test[i, \"profile_pic\"] <- 1\n  } else {\n    datosFCA_test[i, \"no_profile_pic\"] <- 1\n  }\n  \n  # nums.length_username\n  if (datosDF_FCA_test[i, \"nums.length_username\"] < 0.307) {\n    datosFCA_test[i, \"nums_lun_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"nums.length_username\"] < 0.613) {\n    datosFCA_test[i, \"nums_lun_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"nums_lun_high\"] <- 1\n  }\n  \n  # fullname_words\n  if (datosDF_FCA_test[i, \"fullname_words\"] < 1) {\n    datosFCA_test[i, \"fn_words_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"fullname_words\"] < 2) {\n    datosFCA_test[i, \"fn_words_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"fn_words_high\"] <- 1\n  }\n  \n  # nums.length_fullname\n  if (datosDF_FCA_test[i, \"nums.length_fullname\"] < 0.333) {\n    datosFCA_test[i, \"nums_lfn_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"nums.length_fullname\"] < 0.667) {\n    datosFCA_test[i, \"nums_lfn_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"nums_lfn_high\"] <- 1\n  }\n  \n  # Name.equals.username\n  if (datosDF_FCA_test[i, \"name..username\"] == 1) {\n    datosFCA_test[i, \"fn_equals_un\"] <- 1\n  } else {\n    datosFCA_test[i, \"fn_notequals_un\"] <- 1\n  }\n  \n  # description_length\n  if (datosDF_FCA_test[i, \"description_length\"] < 50) {\n    datosFCA_test[i, \"desc_length_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"description_length\"] < 100) {\n    datosFCA_test[i, \"desc_length_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"desc_length_high\"] <- 1\n  }\n  \n  # external_URL\n  if (datosDF_FCA_test[i, \"external_URL\"] == 1) {\n    datosFCA_test[i, \"url\"] <- 1\n  } else {\n    datosFCA_test[i, \"no_url\"] <- 1\n  }\n  \n  # private\n  if (datosDF_FCA_test[i, \"private\"] == 1) {\n    datosFCA_test[i, \"private\"] <- 1\n  } else {\n    datosFCA_test[i, \"public\"] <- 1\n  }\n  \n  # posts\n  if (datosDF_FCA_test[i, \"posts\"] < 2) {\n    datosFCA_test[i, \"posts_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"posts\"] < 43.3) {\n    datosFCA_test[i, \"posts_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"posts_high\"] <- 1\n  }\n  \n  # followers\n  if (datosDF_FCA_test[i, \"followers\"] < 54.3) {\n    datosFCA_test[i, \"followers_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"followers\"] < 415) {\n    datosFCA_test[i, \"followers_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"followers_high\"] <- 1\n  }\n  \n  # follows\n  if (datosDF_FCA_test[i, \"follows\"] < 89.3) {\n    datosFCA_test[i, \"follows_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"follows\"] < 432) {\n    datosFCA_test[i, \"follows_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"follows_high\"] <- 1\n  }\n}\n\n# Visualizar la matriz llena\n#datosFCA_test\n```\n\nAhora es momento de filtrar el gran número de reglas obtenidas, para quedarnos solo con las que contienen 'fake' o 'real' en el consecuente, empezando por las 'fake':\n\n```{r}\nreglas_FCA_fake <- subset(reglas_FCA, subset = rhs %oin% \"fake\")\n\n# Desechar las reglas con count < 15\nreglas_FCA_fake <- subset(reglas_FCA_fake, subset = count >= 15)\n\ninspect(reglas_FCA_fake)\n```\n\nComo vemos, hay 15 reglas. Ahora, hagamos lo mismo con las reglas que contienen 'real' en el consecuente:\n\n```{r}\nreglas_FCA_real <- subset(reglas_FCA, subset = rhs %oin% \"real\")\n\n# Desechar las reglas con count < 15\nreglas_FCA_real <- subset(reglas_FCA_real, subset = count >= 15)\n\ninspect(reglas_FCA_real)\n```\n\nVemos que hay 13 reglas. Ahora, unamos las reglas de cuentas falsas y verdaderas en una variable:\n\n```{r}\n# Guardar la unión de las reglas fake y real\nreglas_FCA_real_fake <- c(reglas_FCA_fake, reglas_FCA_real)\ninspect(reglas_FCA_real_fake)\n```\n\nHay 28 reglas en total.\n\nAhora, vamos a predecir la veracidad de las cuentas en el dataset de test usando las reglas obtenidas:\n\n```{r}\n# Leer el archivo CSV\ndatos_test_predicciones <- read.csv(\"datos_test_predicciones.csv\")\n\n# Crear la fila vacía 'fake_predict_FCA' en 'datos_test_predicciones'\ndatos_test_predicciones$fake_predict_FCA <- NA\n\n# Bucle para recorrer cada fila de la matriz datosFCA_test\nfor (i in 1:nrow(datosFCA_test)) {\n  # Obtener los nombres de las columnas de la fila presente (donde el valor es 1)\n  columnas_presentes <- colnames(datosFCA_test)[datosFCA_test[i, ] == 1]\n  \n  # Bucle para recorrer cada regla en reglas_FCA_real_fake\n  for (j in 1:length(reglas_FCA_real_fake)) {\n    # Obtener el lhs de la regla j\n    lhs_rule <- as(lhs(reglas_FCA_real_fake[j]), \"list\")[[1]]\n    \n    # Comprobar si el lhs de la regla es subconjunto de columnas_presentes\n    if (all(lhs_rule %in% columnas_presentes)) {\n      # Obtener el rhs (consecuente) de la regla\n      rhs_rule <- labels(rhs(reglas_FCA_real_fake[j]))[1]\n      \n      # Asignar el valor numérico según el contenido del consecuente\n      if (grepl(\"real\", rhs_rule)) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 0\n      } else if (grepl(\"fake\", rhs_rule)) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 1\n      }\n      \n      break  # Salir del bucle una vez encontrada una regla aplicable\n    }\n    \n    # Si no se ha encontrado ninguna regla aplicable, se sigue esta heurística:\n    else {\n      # Si la cuenta tiene URL externa, es verdadera\n      if (\"url\" %in% columnas_presentes) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 0\n      }\n      # Si la cuenta no tiene foto de perfil, es falsa\n      else if (\"no_profile_pic\" %in% columnas_presentes) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 1\n      }\n      # Si la cuenta tiene menos de 250 seguido, es falsa\n      else if (\"follows_low\" %in% columnas_presentes) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 1\n      }\n      # En otro caso, consideramos que es verdadera\n      else {\n        datos_test_predicciones$fake_predict_FCA[i] <- 0\n      }\n    }\n  }\n}\n\n#View(datos_test_predicciones)\nhead(datos_test_predicciones)\n```\n\nVemos que hay valores 0/1 en la columna fake_predict_FCA.\n\nAhora, contemos el número de valores NA en la columna fake_predict_FCA:\n\n```{r}\n# Contar el número de valores NA en la columna fake_predict_FCA\ncat(\"La columna fake_predict_FCA tiene \", sum(is.na(datos_test_predicciones$fake_predict_FCA)), \" valores NA\")\n```\n\nParece que la predicción ha sido satisfactoria. Ahora, calculemos el porcentaje de éxito en la predicción de cuentas falsas, de cuentas verdaderas y en general:\n\n```{r}\n# Calcular el porcentaje de éxito en la predicción de cuentas falsas\npredicciones_correctas_falsas_FCA <- sum(datos_test_predicciones$fake_predict_FCA == datos_test_predicciones$fake & datos_test_predicciones$fake == 1)\ntotal_falsas_FCA <- sum(datos_test_predicciones$fake == 1)\nporcentaje_exito_falsas_FCA <- (predicciones_correctas_falsas_FCA / total_falsas_FCA) * 100\n\n# Calcular el porcentaje de éxito en la predicción de cuentas verdaderas\npredicciones_correctas_verdaderas_FCA <- sum(datos_test_predicciones$fake_predict_FCA == datos_test_predicciones$fake & datos_test_predicciones$fake == 0)\ntotal_verdaderas_FCA <- sum(datos_test_predicciones$fake == 0)\nporcentaje_exito_verdaderas_FCA <- (predicciones_correctas_verdaderas_FCA / total_verdaderas_FCA) * 100\n\n# Calcular el porcentaje de éxito general\npredicciones_correctas_FCA <- sum(datos_test_predicciones$fake_predict_FCA == datos_test_predicciones$fake)\ntotal_predicciones_FCA <- nrow(datos_test_predicciones)\nporcentaje_exito_general_FCA <- (predicciones_correctas_FCA / total_predicciones_FCA) * 100\n\n# Guardar el data frame en un archivo CSV\nwrite.csv(datos_test_predicciones, \"datos_test_predicciones.csv\", row.names = FALSE)\n\n\n# Imprimir el resultado\ncat(\"El porcentaje de éxito en la predicción de cuentas falsas es:\", porcentaje_exito_falsas_FCA, \"%\\n\", \"El porcentaje de éxito en la predicción de cuentas verdaderas es:\", porcentaje_exito_verdaderas_FCA, \"%\\n\", \"El porcentaje de éxito general en la predicción de cuentas es:\", porcentaje_exito_general_FCA, \"%\\n\")\n```\n\nComo vemos, los porcentajes de éxito son muy altos, lo que indica que el modelo de regresión ha sido efectivo en la predicción de cuentas falsas y verdaderas.\n\nAñadamos los porcentajes de éxito a la tabla de porcentajes:\n\n```{r}\n# Leer el archivo CSV\nexito_predicciones <- read.csv(\"exito_predicciones.csv\")\n\n# Añadir los porcentajes de éxito a la tabla de porcentajes\nexito_predicciones <- rbind(exito_predicciones, c(\"FCA\", porcentaje_exito_falsas_FCA, porcentaje_exito_verdaderas_FCA, porcentaje_exito_general_FCA))\nexito_predicciones\n\n# Guardar el data frame en un archivo CSV\nwrite.csv(exito_predicciones, \"exito_predicciones.csv\", row.names = FALSE)\n```\n\nLas reglas de asociación han rendido algo mejor que FCA en la predicción de cuentas falsas, pero el formal concept analysis ha sido bastante mejor en la predicción de cuentas verdaderas (20 puntos por encima) y en general. FCA ha sido 8 puntos más efectivo que reglas de asociación en la predicción general.\n\n","srcMarkdownNoYaml":"\n\n```{r warning=FALSE, message=FALSE}\n# Librerías, datasets y procesamiento previo\nlibrary(readr)\nlibrary(dplyr)\nlibrary(fcaR)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(psych)\nlibrary(arules)\n\ndatos <- read_csv(\"train.csv\")\nView(datos)\ndatos_test <- read_csv(\"test.csv\")\nView(datos_test)\n\ndatos <- rename(datos, profile_pic=`profile pic`, `nums/length_username` = `nums/length username`, fullname_words=`fullname words`, `nums/length_fullname` = `nums/length fullname`, description_length=`description length`, external_URL=`external URL`, posts=`#posts`, followers=`#followers`, follows=`#follows`)\n\ndatos_test <- rename(datos_test, profile_pic=`profile pic`, `nums/length_username` = `nums/length username`, fullname_words=`fullname words`, `nums/length_fullname` = `nums/length fullname`, description_length=`description length`, external_URL=`external URL`, posts=`#posts`, followers=`#followers`, follows=`#follows`)\n```\n\n## Formal Concept Analysis\n\nYa hemos extraído información importante sobre patrones encontrados en los datos, concretamente sobre qué atributos o combinaciones de ellos determinan, con mayor o menor influencia, si una cuenta es legítima o falsa. Sin embargo, el estudio de reglas de asociación no es la única forma de extraer información en cuanto a las relaciones entre variables y el descubrimiento de patrones: es momento de estudiar lo que se conoce como \"Formal Concept Analysis\".\n\n### Obtención de las reglas de FCA\n\nMi primer paso para trabajar con FCA va a consistir en construir una matriz, cuyas filas serán las cuentas del dataset, cuyas columnas serán los valores discretizados de las variables (2 columnas por cada variable binaria y 3 por cada variable numérica) y cuyas celdas serán valores 0/1, en función del valor discretizado que cumpla esa cuenta para cada variable. Es decir, trabajaremos con un formal context binario.\n\nPara comenzar con esta aproximación, antes es necesario ajustar un poco los intervalos de las variables numéricas que hemos visto en reglas de asociación, para que haya 3 categorías (serán high, med y low). En las variables binarias seguimos el mismo procedimiento que en reglas de asociación.\n\n```{r}\ndatosDF_FCA_intervalos <- data.frame(datos)\nView(datosDF_FCA_intervalos)\n\n# Discretizar columnas numéricas\ndatosDF_FCA_intervalos$nums.length_username <- discretize(datosDF_FCA_intervalos$nums.length_username, method=\"interval\", breaks = 3)\ndatosDF_FCA_intervalos$fullname_words <- discretize(datosDF_FCA_intervalos$fullname_words, method=\"frequency\", breaks = 3)\ndatosDF_FCA_intervalos$nums.length_fullname <- discretize(datosDF_FCA_intervalos$nums.length_fullname, method=\"interval\", breaks = 3)\ndatosDF_FCA_intervalos$description_length <- discretize(datosDF_FCA_intervalos$description_length, method=\"interval\", breaks = 3)\ndatosDF_FCA_intervalos$posts <- discretize(datosDF_FCA_intervalos$posts, method=\"frequency\", breaks = 3)\ndatosDF_FCA_intervalos$followers <- discretize(datosDF_FCA_intervalos$followers, method=\"frequency\", breaks = 3)\ndatosDF_FCA_intervalos$follows <- discretize(datosDF_FCA_intervalos$follows, method=\"frequency\", breaks = 3)\n\n# Identificar las columnas binarias y numéricas\ncolumnas_binarias <- c(1, 5, 7, 8, 12) # Índices de las columnas binarias\n\n# Convertir columnas binarias a factores\ndatosDF_FCA_intervalos[, columnas_binarias] <- lapply(datosDF_FCA_intervalos[, columnas_binarias], factor)\nView(datosDF_FCA_intervalos)\n\n\n```\n\nYa tenemos los nuevos intervalos ajustados. Ahora toca imprimir los valores de esos intervalos, que usaremos posteriormente para definir los valores de cada cuenta en la matriz:\n\n```{r}\n# Obtener los niveles de cada variable recorriendo las columnas\nfor (col_name in names(datosDF_FCA_intervalos)) {\n  col <- datosDF_FCA_intervalos[[col_name]]\n  if (is.factor(col)) {\n    cat(length(levels(col)), \" niveles en\", col_name, \":\", levels(col), \"\\n\")\n  }\n}\n```\n\nAhora ya tenemos los valores posibles que puede tomar cada variable. En las variables binarias, naturalmente los valores posibles son 0 y 1; en las numéricas hay 3 intervalos por variable.\n\nLo siguiente sería definir los atributos (categorías de las variables):\n\n```{r}\ndatosDF_FCA <- data.frame(datos)\nView(datosDF_FCA)\n\n# Crear un vector con los nombres de los atributos (categorías)\nattributes <- c(\"profile_pic\", \"no_profile_pic\",\n                \"nums_lun_high\", \"nums_lun_med\", \"nums_lun_low\",\n                \"fn_words_high\", \"fn_words_med\", \"fn_words_low\",\n                \"nums_lfn_high\", \"nums_lfn_med\", \"nums_lfn_low\",\n                \"fn_equals_un\", \"fn_notequals_un\",\n                \"desc_length_high\", \"desc_length_med\", \"desc_length_low\",\n                \"url\", \"no_url\",\n                \"private\", \"public\",\n                \"posts_high\", \"posts_med\", \"posts_low\",\n                \"followers_high\", \"followers_med\", \"followers_low\",\n                \"follows_high\", \"follows_med\", \"follows_low\",\n                \"fake\", \"real\")\n```\n\nUna vez tenemos definidos los atributos, es hora de crear el esqueleto de la matriz sobre la que aplicaremos FCA:\n\n```{r}\n# Crear un vector con los nombres de las cuentas\naccounts <- rownames(datosDF_FCA)\n\n# Crear una matriz de ceros con el mismo número de filas que cuentas y el mismo número de columnas que atributos\ndatosFCA <- matrix(0, nrow = nrow(datosDF_FCA), ncol = length(attributes))\n\n# Nombrar las filas y columnas\nrownames(datosFCA) <- accounts\ncolnames(datosFCA) <- attributes\n\n# Visualizar la matriz vacía\n#datosFCA\n```\n\nNuestra matriz vacía está lista. Ahora debemos llenarla, y para ello recorreremos cada fila del data frame, y examinaremos los valores de las columnas de esa fila. En función del valor que tome (comparado con los intervalos ajustados de antes), asignaremos un 1 o un 0 en la columna (categoría) correspondiente de la matriz para esa fila:\n\n```{r}\n# Iterar sobre cada fila del dataset y actualizar los valores en la matriz de acuerdo a los intervalos de las variables\nfor (i in 1:nrow(datosDF_FCA)) {\n  # profile_pic\n  if (datosDF_FCA[i, \"profile_pic\"] == 1) {\n    datosFCA[i, \"profile_pic\"] <- 1\n  } else {\n    datosFCA[i, \"no_profile_pic\"] <- 1\n  }\n  \n  # nums.length_username\n  if (datosDF_FCA[i, \"nums.length_username\"] < 0.307) {\n    datosFCA[i, \"nums_lun_low\"] <- 1\n  } else if (datosDF_FCA[i, \"nums.length_username\"] < 0.613) {\n    datosFCA[i, \"nums_lun_med\"] <- 1\n  } else {\n    datosFCA[i, \"nums_lun_high\"] <- 1\n  }\n  \n  # fullname_words\n  if (datosDF_FCA[i, \"fullname_words\"] < 1) {\n    datosFCA[i, \"fn_words_low\"] <- 1\n  } else if (datosDF_FCA[i, \"fullname_words\"] < 2) {\n    datosFCA[i, \"fn_words_med\"] <- 1\n  } else {\n    datosFCA[i, \"fn_words_high\"] <- 1\n  }\n  \n  # nums.length_fullname\n  if (datosDF_FCA[i, \"nums.length_fullname\"] < 0.333) {\n    datosFCA[i, \"nums_lfn_low\"] <- 1\n  } else if (datosDF_FCA[i, \"nums.length_fullname\"] < 0.667) {\n    datosFCA[i, \"nums_lfn_med\"] <- 1\n  } else {\n    datosFCA[i, \"nums_lfn_high\"] <- 1\n  }\n  \n  # Name.equals.username\n  if (datosDF_FCA[i, \"name..username\"] == 1) {\n    datosFCA[i, \"fn_equals_un\"] <- 1\n  } else {\n    datosFCA[i, \"fn_notequals_un\"] <- 1\n  }\n  \n  # description_length\n  if (datosDF_FCA[i, \"description_length\"] < 50) {\n    datosFCA[i, \"desc_length_low\"] <- 1\n  } else if (datosDF_FCA[i, \"description_length\"] < 100) {\n    datosFCA[i, \"desc_length_med\"] <- 1\n  } else {\n    datosFCA[i, \"desc_length_high\"] <- 1\n  }\n  \n  # external_URL\n  if (datosDF_FCA[i, \"external_URL\"] == 1) {\n    datosFCA[i, \"url\"] <- 1\n  } else {\n    datosFCA[i, \"no_url\"] <- 1\n  }\n  \n  # private\n  if (datosDF_FCA[i, \"private\"] == 1) {\n    datosFCA[i, \"private\"] <- 1\n  } else {\n    datosFCA[i, \"public\"] <- 1\n  }\n  \n  # posts\n  if (datosDF_FCA[i, \"posts\"] < 2) {\n    datosFCA[i, \"posts_low\"] <- 1\n  } else if (datosDF_FCA[i, \"posts\"] < 43.3) {\n    datosFCA[i, \"posts_med\"] <- 1\n  } else {\n    datosFCA[i, \"posts_high\"] <- 1\n  }\n  \n  # followers\n  if (datosDF_FCA[i, \"followers\"] < 54.3) {\n    datosFCA[i, \"followers_low\"] <- 1\n  } else if (datosDF_FCA[i, \"followers\"] < 415) {\n    datosFCA[i, \"followers_med\"] <- 1\n  } else {\n    datosFCA[i, \"followers_high\"] <- 1\n  }\n  \n  # follows\n  if (datosDF_FCA[i, \"follows\"] < 89.3) {\n    datosFCA[i, \"follows_low\"] <- 1\n  } else if (datosDF_FCA[i, \"follows\"] < 432) {\n    datosFCA[i, \"follows_med\"] <- 1\n  } else {\n    datosFCA[i, \"follows_high\"] <- 1\n  }\n  \n  # fake\n  if (datosDF_FCA[i, \"fake\"] == 1) {\n    datosFCA[i, \"fake\"] <- 1\n  } else {\n    datosFCA[i, \"real\"] <- 1\n  }\n}\n\n# Visualizar la matriz llena\n#datosFCA\n```\n\nAhora viene lo interesante: convertir la matriz a un objeto formalcontext y trabajar con FCA.\n\n```{r}\n# Convertir la matriz a un objeto FormalContext\nfc_datos <- FormalContext$new(datosFCA)\nfc_datos\n```\n\nVemos que la conversión ha sido exitosa. Además de ver la tabla, podemos hacer un plot para visualizar el resultado:\n\n```{r}\n# Visualizar el formal context\nfc_datos$plot()\n```\n\nNaturalmente, al ser tantos datos, no podemos ver bien cada fila. Sin embargo, podemos ver patrones que concuerdan con nuestro dataset: la última columna es 'fake', y sabemos que la primera mitad de filas son cuentas reales, y la segunda mitad, cuentas falsas, tal y como indican las barras negras del final del plot.\n\nObservemos más de cerca el plot (5 primeras filas):\n\n```{r}\nfc_datos[1:5]$plot()\n```\n\nComo vemos, las barras negras concuerdan perfectamente con nuestro dataset. Parece que hemos tenido éxito. También podemos comprobar este éxito usando el extent y el intent:\n\n```{r}\nS1 <- Set$new(fc_datos$attributes)\nS1$assign(fake=1)\n\n# Extent (filas) de las cuentas fake\nS2 <- fc_datos$extent(S1)\nS2\n```\n\nEl extent lista los nombres de las filas con cuentas que cumplen las condiciones establecidas en S1 (las cuentas son fake). Echando un vistazo al dataset, comprobamos que las filas de la salida (289-576) son las cuentas fake. También existe el concepto de intent, el cual devuelve el conjunto de características que comparte un conjunto de filas. Por esa lógica, si hiciéramos el intent de S2 (cuentas fake), debería devolvernos fake y no_url, dado que ninguna cuenta fake tiene URL externa:\n\n```{r}\n# Intent (características) de las cuentas fake\nfc_datos$intent(S2)\n```\n\nUna vez más, parece que ha habido éxito.\n\nAhora es momento de encontrar las implicaciones:\n\n```{r}\n# Encontrar implicaciones\nfc_datos$find_implications()\n\n# Número de implicaciones encontradas\nfc_datos$implications$cardinality()\n```\n\nAhora que sabemos que hay un número considerable de implicaciones, intentemos reducir la cantidad eliminando redundancias:\n\n```{r}\nfc_datos$implications$apply_rules(rules = c(\"composition\",\n                                      \"generalization\",\n                                      \"simplification\"),\n                            parallelize = FALSE)\n```\n\nParece que ninguna de las implicaciones originales era redundante. Echemos un vistazo a las primeras 20 implicaciones:\n\n```{r}\nfc_datos$implications[1:20]\n```\n\nAhora es el momento de extraer conocimiento con las implicaciones que nos interesan (variable fake en el consecuente de la regla).\n\nComencemos con las reglas cuyo consecuente es únicamente 'fake' (si además de fake se dejan otras variables, el resultado tiene mucho ruido y reglas extrañas):\n\n```{r}\n# Implicaciones con 'fake' en el consecuente\nfc_datos$implications$filter(rhs = \"fake\", not_rhs = attributes[-which(attributes == \"fake\")])\n```\n\nBasándonos en estas reglas, podemos considerar que una cuenta es falsa cuando identificamos ciertas combinaciones de estas características:\n\n-   Pocas o nulas publicaciones (igual que en reglas de asociación)\n-   Descripción vacía o muy breve (igual que en reglas de asociación)\n-   Ausencia de foto de perfil (igual que en reglas de asociación)\n-   Pocos o nulos seguidos (igual que en reglas de asociación)\n-   Ausencia de URL externa (igual que en reglas de asociación)\n-   Bajo número de seguidores\n\nComo vemos, las conclusiones generales son muy similares a las obtenidas con arules.\n\nAhora veamos los antecedentes para cuentas verdaderas:\n\n```{r}\n# Implicaciones con 'real' en el consecuente\nfc_datos$implications$filter(rhs = \"real\", not_rhs = attributes[-which(attributes == \"real\")])\n```\n\nBasándonos en estas reglas, podemos considerar que una cuenta es verdadera cuando identificamos ciertas combinaciones de estas características:\n\n-   Ratio de números en la longitud del username bajo (igual que en reglas de asociación)\n-   Cantidad considerable de palabras en el nombre completo (igual que en reglas de asociación)\n-   Presencia de foto de perfil (igual que en reglas de asociación)\n-   Descripción detallada (igual que en reglas de asociación)\n-   Número alto de publicaciones (igual que en reglas de asociación)\n-   Número considerable de seguidores (ya comentamos que este parámetro faltó en reglas de asociación, pero aquí sí aparece)\n\nLas conclusiones generales para cuentas verdaderas también son muy similares a las obtenidas con arules.\n\n### Predicción\n\nAhora es el momento de usar las reglas obtenidas para predecir la veracidad de las cuentas en el dataset de test. Para ello, debemos organizar los datos de test de la misma forma que los de entrenamiento. Como me ha gustado el modo de trabajar con el formato de reglas de arules, primero convertiré las reglas obtenidas a arules para poder aplicarlas a los datos de test.\n\n```{r}\n# Convertir las implicaciones a reglas de asociación\nreglas_FCA <- fc_datos$implications$to_arules()\n\n# Mostrar la primera regla obtenida\ninspect(reglas_FCA[1])\n```\n\nMostremos el número de reglas obtenidas, que debería ser 1292:\n\n```{r}\n# Número de reglas obtenidas\nlength(reglas_FCA)\n```\n\nParece que las reglas se han convertido con éxito a formato arules.\n\nAhora, debemos crear una matriz de datos de test con las mismas características que la matriz de datos de entrenamiento:\n\n```{r}\n# Crear un vector con los nombres de las cuentas\naccounts <- rownames(datos_test)\n\n# Crear lista con atributos para las filas de test (sin real ni fake)\nattributes_test <- attributes[-which(attributes %in% c(\"fake\", \"real\"))]\n\n# Crear una matriz de ceros con el mismo número de filas que cuentas y el mismo número de columnas que atributos\ndatosFCA_test <- matrix(0, nrow = nrow(datos_test), ncol = length(attributes_test))\n\n# Nombrar las filas y columnas\nrownames(datosFCA_test) <- accounts\ncolnames(datosFCA_test) <- attributes_test\n\n# Visualizar la matriz vacía\n#datosFCA_test\n```\n\nAhora, debemos llenar la matriz de datos de test con los valores correspondientes a cada cuenta, fijándonos en los intervalos generados para las cuentas de entrenamiento:\n\n```{r}\ndatosDF_FCA_test <- data.frame(datos_test)\n\n# Iterar sobre cada fila del dataset y actualizar los valores en la matriz de acuerdo a los intervalos de las variables\nfor (i in 1:nrow(datosDF_FCA_test)) {\n  # profile_pic\n  if (datosDF_FCA_test[i, \"profile_pic\"] == 1) {\n    datosFCA_test[i, \"profile_pic\"] <- 1\n  } else {\n    datosFCA_test[i, \"no_profile_pic\"] <- 1\n  }\n  \n  # nums.length_username\n  if (datosDF_FCA_test[i, \"nums.length_username\"] < 0.307) {\n    datosFCA_test[i, \"nums_lun_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"nums.length_username\"] < 0.613) {\n    datosFCA_test[i, \"nums_lun_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"nums_lun_high\"] <- 1\n  }\n  \n  # fullname_words\n  if (datosDF_FCA_test[i, \"fullname_words\"] < 1) {\n    datosFCA_test[i, \"fn_words_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"fullname_words\"] < 2) {\n    datosFCA_test[i, \"fn_words_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"fn_words_high\"] <- 1\n  }\n  \n  # nums.length_fullname\n  if (datosDF_FCA_test[i, \"nums.length_fullname\"] < 0.333) {\n    datosFCA_test[i, \"nums_lfn_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"nums.length_fullname\"] < 0.667) {\n    datosFCA_test[i, \"nums_lfn_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"nums_lfn_high\"] <- 1\n  }\n  \n  # Name.equals.username\n  if (datosDF_FCA_test[i, \"name..username\"] == 1) {\n    datosFCA_test[i, \"fn_equals_un\"] <- 1\n  } else {\n    datosFCA_test[i, \"fn_notequals_un\"] <- 1\n  }\n  \n  # description_length\n  if (datosDF_FCA_test[i, \"description_length\"] < 50) {\n    datosFCA_test[i, \"desc_length_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"description_length\"] < 100) {\n    datosFCA_test[i, \"desc_length_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"desc_length_high\"] <- 1\n  }\n  \n  # external_URL\n  if (datosDF_FCA_test[i, \"external_URL\"] == 1) {\n    datosFCA_test[i, \"url\"] <- 1\n  } else {\n    datosFCA_test[i, \"no_url\"] <- 1\n  }\n  \n  # private\n  if (datosDF_FCA_test[i, \"private\"] == 1) {\n    datosFCA_test[i, \"private\"] <- 1\n  } else {\n    datosFCA_test[i, \"public\"] <- 1\n  }\n  \n  # posts\n  if (datosDF_FCA_test[i, \"posts\"] < 2) {\n    datosFCA_test[i, \"posts_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"posts\"] < 43.3) {\n    datosFCA_test[i, \"posts_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"posts_high\"] <- 1\n  }\n  \n  # followers\n  if (datosDF_FCA_test[i, \"followers\"] < 54.3) {\n    datosFCA_test[i, \"followers_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"followers\"] < 415) {\n    datosFCA_test[i, \"followers_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"followers_high\"] <- 1\n  }\n  \n  # follows\n  if (datosDF_FCA_test[i, \"follows\"] < 89.3) {\n    datosFCA_test[i, \"follows_low\"] <- 1\n  } else if (datosDF_FCA_test[i, \"follows\"] < 432) {\n    datosFCA_test[i, \"follows_med\"] <- 1\n  } else {\n    datosFCA_test[i, \"follows_high\"] <- 1\n  }\n}\n\n# Visualizar la matriz llena\n#datosFCA_test\n```\n\nAhora es momento de filtrar el gran número de reglas obtenidas, para quedarnos solo con las que contienen 'fake' o 'real' en el consecuente, empezando por las 'fake':\n\n```{r}\nreglas_FCA_fake <- subset(reglas_FCA, subset = rhs %oin% \"fake\")\n\n# Desechar las reglas con count < 15\nreglas_FCA_fake <- subset(reglas_FCA_fake, subset = count >= 15)\n\ninspect(reglas_FCA_fake)\n```\n\nComo vemos, hay 15 reglas. Ahora, hagamos lo mismo con las reglas que contienen 'real' en el consecuente:\n\n```{r}\nreglas_FCA_real <- subset(reglas_FCA, subset = rhs %oin% \"real\")\n\n# Desechar las reglas con count < 15\nreglas_FCA_real <- subset(reglas_FCA_real, subset = count >= 15)\n\ninspect(reglas_FCA_real)\n```\n\nVemos que hay 13 reglas. Ahora, unamos las reglas de cuentas falsas y verdaderas en una variable:\n\n```{r}\n# Guardar la unión de las reglas fake y real\nreglas_FCA_real_fake <- c(reglas_FCA_fake, reglas_FCA_real)\ninspect(reglas_FCA_real_fake)\n```\n\nHay 28 reglas en total.\n\nAhora, vamos a predecir la veracidad de las cuentas en el dataset de test usando las reglas obtenidas:\n\n```{r}\n# Leer el archivo CSV\ndatos_test_predicciones <- read.csv(\"datos_test_predicciones.csv\")\n\n# Crear la fila vacía 'fake_predict_FCA' en 'datos_test_predicciones'\ndatos_test_predicciones$fake_predict_FCA <- NA\n\n# Bucle para recorrer cada fila de la matriz datosFCA_test\nfor (i in 1:nrow(datosFCA_test)) {\n  # Obtener los nombres de las columnas de la fila presente (donde el valor es 1)\n  columnas_presentes <- colnames(datosFCA_test)[datosFCA_test[i, ] == 1]\n  \n  # Bucle para recorrer cada regla en reglas_FCA_real_fake\n  for (j in 1:length(reglas_FCA_real_fake)) {\n    # Obtener el lhs de la regla j\n    lhs_rule <- as(lhs(reglas_FCA_real_fake[j]), \"list\")[[1]]\n    \n    # Comprobar si el lhs de la regla es subconjunto de columnas_presentes\n    if (all(lhs_rule %in% columnas_presentes)) {\n      # Obtener el rhs (consecuente) de la regla\n      rhs_rule <- labels(rhs(reglas_FCA_real_fake[j]))[1]\n      \n      # Asignar el valor numérico según el contenido del consecuente\n      if (grepl(\"real\", rhs_rule)) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 0\n      } else if (grepl(\"fake\", rhs_rule)) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 1\n      }\n      \n      break  # Salir del bucle una vez encontrada una regla aplicable\n    }\n    \n    # Si no se ha encontrado ninguna regla aplicable, se sigue esta heurística:\n    else {\n      # Si la cuenta tiene URL externa, es verdadera\n      if (\"url\" %in% columnas_presentes) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 0\n      }\n      # Si la cuenta no tiene foto de perfil, es falsa\n      else if (\"no_profile_pic\" %in% columnas_presentes) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 1\n      }\n      # Si la cuenta tiene menos de 250 seguido, es falsa\n      else if (\"follows_low\" %in% columnas_presentes) {\n        datos_test_predicciones$fake_predict_FCA[i] <- 1\n      }\n      # En otro caso, consideramos que es verdadera\n      else {\n        datos_test_predicciones$fake_predict_FCA[i] <- 0\n      }\n    }\n  }\n}\n\n#View(datos_test_predicciones)\nhead(datos_test_predicciones)\n```\n\nVemos que hay valores 0/1 en la columna fake_predict_FCA.\n\nAhora, contemos el número de valores NA en la columna fake_predict_FCA:\n\n```{r}\n# Contar el número de valores NA en la columna fake_predict_FCA\ncat(\"La columna fake_predict_FCA tiene \", sum(is.na(datos_test_predicciones$fake_predict_FCA)), \" valores NA\")\n```\n\nParece que la predicción ha sido satisfactoria. Ahora, calculemos el porcentaje de éxito en la predicción de cuentas falsas, de cuentas verdaderas y en general:\n\n```{r}\n# Calcular el porcentaje de éxito en la predicción de cuentas falsas\npredicciones_correctas_falsas_FCA <- sum(datos_test_predicciones$fake_predict_FCA == datos_test_predicciones$fake & datos_test_predicciones$fake == 1)\ntotal_falsas_FCA <- sum(datos_test_predicciones$fake == 1)\nporcentaje_exito_falsas_FCA <- (predicciones_correctas_falsas_FCA / total_falsas_FCA) * 100\n\n# Calcular el porcentaje de éxito en la predicción de cuentas verdaderas\npredicciones_correctas_verdaderas_FCA <- sum(datos_test_predicciones$fake_predict_FCA == datos_test_predicciones$fake & datos_test_predicciones$fake == 0)\ntotal_verdaderas_FCA <- sum(datos_test_predicciones$fake == 0)\nporcentaje_exito_verdaderas_FCA <- (predicciones_correctas_verdaderas_FCA / total_verdaderas_FCA) * 100\n\n# Calcular el porcentaje de éxito general\npredicciones_correctas_FCA <- sum(datos_test_predicciones$fake_predict_FCA == datos_test_predicciones$fake)\ntotal_predicciones_FCA <- nrow(datos_test_predicciones)\nporcentaje_exito_general_FCA <- (predicciones_correctas_FCA / total_predicciones_FCA) * 100\n\n# Guardar el data frame en un archivo CSV\nwrite.csv(datos_test_predicciones, \"datos_test_predicciones.csv\", row.names = FALSE)\n\n\n# Imprimir el resultado\ncat(\"El porcentaje de éxito en la predicción de cuentas falsas es:\", porcentaje_exito_falsas_FCA, \"%\\n\", \"El porcentaje de éxito en la predicción de cuentas verdaderas es:\", porcentaje_exito_verdaderas_FCA, \"%\\n\", \"El porcentaje de éxito general en la predicción de cuentas es:\", porcentaje_exito_general_FCA, \"%\\n\")\n```\n\nComo vemos, los porcentajes de éxito son muy altos, lo que indica que el modelo de regresión ha sido efectivo en la predicción de cuentas falsas y verdaderas.\n\nAñadamos los porcentajes de éxito a la tabla de porcentajes:\n\n```{r}\n# Leer el archivo CSV\nexito_predicciones <- read.csv(\"exito_predicciones.csv\")\n\n# Añadir los porcentajes de éxito a la tabla de porcentajes\nexito_predicciones <- rbind(exito_predicciones, c(\"FCA\", porcentaje_exito_falsas_FCA, porcentaje_exito_verdaderas_FCA, porcentaje_exito_general_FCA))\nexito_predicciones\n\n# Guardar el data frame en un archivo CSV\nwrite.csv(exito_predicciones, \"exito_predicciones.csv\", row.names = FALSE)\n```\n\nLas reglas de asociación han rendido algo mejor que FCA en la predicción de cuentas falsas, pero el formal concept analysis ha sido bastante mejor en la predicción de cuentas verdaderas (20 puntos por encima) y en general. FCA ha sido 8 puntos más efectivo que reglas de asociación en la predicción general.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"fca.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["references.bib"],"editor":"visual","theme":"cosmo","title":"Formal Concept Analysis"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"fca.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"editor":"visual","documentclass":"scrreprt","title":"Formal Concept Analysis"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}